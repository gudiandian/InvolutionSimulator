# 1. 给定人数、每个人初始的投入努力，考虑到其他人的情况，如果提升自己的努力程度E可以升高实际效用I，则参与者会选择增加E，求解他们最后的平衡状态，即无法通过提高E而增加I
# 2. g,f,I三个函数这里只是一个示例，不同的函数肯定会对于最后结果有不同的影响
#（抱歉诸位学长学姐，因为我理解的第一部分好像是这样做的，但是又感觉太简单了，如果诸位学长学姐认为我做的需要改进的地方，请您尽管批评指教

import networkx as nx
import argparse
import numpy as np
def g(E): #心理成本，关于E的导数单调递增
    return E**2
def f(E, other_effort):#其他人回报，关于other_effort偏导为负数，关于E导数单调递减
    return 100*E-0.01*other_effort
def I(E,other_effort):#实际效用
    return f(E,other_effort)-g(E)
if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('--n', type=int, default=10, help='number of nodes in the network')
	args = parser.parse_args()
	G=nx.Graph() 	# 创建空的简单无向图
	effort_list=[]	# 每个节点的卷度
	sum_of_effort=0
	for i in range(1, args.n + 1):
		G.add_nodes_from([(i, {'effort': round(np.random.random((1, 1))[0][0], 2)})])
	node_labels = nx.get_node_attributes(G, 'effort')
	for i in range(1, args.n + 1):
		effort_list.append(node_labels[i])
	flag = 0
	num = 1
	while True:
		print('第 %d 次迭代' % (num))
		num = num + 1
		flag = 0
		index = 0
		sum_of_effort = sum(effort_list)
		for E in effort_list:
			print('第 %d 个人的实际效用为 %f' % (index, I(E, (sum_of_effort - E) / (args.n - 1))))
			print('第 %d 个人增开努力后的实际效用为 %f' % (index, I(E + 1, (sum_of_effort - E) / (args.n - 1))))
			if I(E + 1, (sum_of_effort - E) / (args.n - 1)) > I(E, (sum_of_effort - E) / (args.n - 1)):
				effort_list[index] = effort_list[index] + 1
				flag = 1
			index = index + 1
		print(effort_list)
		if flag == 0:
			break
